var E=2,d=(t,e)=>{let r=t.get(e);if(!r)for(const[n,i]of t.entries()){const o=n.replace(/[.*+?^${}()|[\]\\]/g,"\\$&").replace(/\\\*/g,".*");if(new RegExp(`^${o}$`).test(e)){r=i;break}}return r},S=(t,e,r)=>d(t,r)?.get(e),p=/^[A-Za-z0-9+/]*={0,2}$/;function k(t){return typeof globalThis<"u"&&typeof globalThis.btoa=="function"?globalThis.btoa(t):Buffer.from(t).toString("base64")}function g(t){return typeof globalThis<"u"&&typeof globalThis.atob=="function"?globalThis.atob(t):Buffer.from(t,"base64").toString("utf-8")}var u=class{constructor(t){this.client=t}encodePaymentSignatureHeader(t){switch(t.x402Version){case 2:return{"PAYMENT-SIGNATURE":y(t)};case 1:return{"X-PAYMENT":y(t)};default:throw new Error(`Unsupported x402 version: ${t.x402Version}`)}}getPaymentRequiredResponse(t,e){const r=t("PAYMENT-REQUIRED");if(r)return x(r);if(e&&e instanceof Object&&"x402Version"in e&&e.x402Version===1)return e;throw new Error("Invalid payment required response")}getPaymentSettleResponse(t){const e=t("PAYMENT-RESPONSE");if(e)return w(e);const r=t("X-PAYMENT-RESPONSE");if(r)return w(r);throw new Error("Payment response header not found")}async createPaymentPayload(t){return this.client.createPaymentPayload(t)}};function y(t){return k(JSON.stringify(t))}function x(t){if(!p.test(t))throw new Error("Invalid payment required header");return JSON.parse(g(t))}function w(t){if(!p.test(t))throw new Error("Invalid payment response header");return JSON.parse(g(t))}var N=class P{constructor(e){this.registeredClientSchemes=new Map,this.policies=[],this.beforePaymentCreationHooks=[],this.afterPaymentCreationHooks=[],this.onPaymentCreationFailureHooks=[],this.paymentRequirementsSelector=e||((r,n)=>n[0])}static fromConfig(e){const r=new P(e.paymentRequirementsSelector);return e.schemes.forEach(n=>{n.x402Version===1?r.registerV1(n.network,n.client):r.register(n.network,n.client)}),e.policies?.forEach(n=>{r.registerPolicy(n)}),r}register(e,r){return this._registerScheme(E,e,r)}registerV1(e,r){return this._registerScheme(1,e,r)}registerPolicy(e){return this.policies.push(e),this}onBeforePaymentCreation(e){return this.beforePaymentCreationHooks.push(e),this}onAfterPaymentCreation(e){return this.afterPaymentCreationHooks.push(e),this}onPaymentCreationFailure(e){return this.onPaymentCreationFailureHooks.push(e),this}async createPaymentPayload(e){const r=this.registeredClientSchemes.get(e.x402Version);if(!r)throw new Error(`No client registered for x402 version: ${e.x402Version}`);const n=this.selectPaymentRequirements(e.x402Version,e.accepts),i={paymentRequired:e,selectedRequirements:n};for(const o of this.beforePaymentCreationHooks){const s=await o(i);if(s&&"abort"in s&&s.abort)throw new Error(`Payment creation aborted: ${s.reason}`)}try{const o=S(r,n.scheme,n.network);if(!o)throw new Error(`No client registered for scheme: ${n.scheme} and network: ${n.network}`);const s=await o.createPaymentPayload(e.x402Version,n);let a;s.x402Version==1?a=s:a={...s,extensions:e.extensions,resource:e.resource,accepted:n};const c={...i,paymentPayload:a};for(const l of this.afterPaymentCreationHooks)await l(c);return a}catch(o){const s={...i,error:o};for(const a of this.onPaymentCreationFailureHooks){const c=await a(s);if(c&&"recovered"in c&&c.recovered)return c.payload}throw o}}selectPaymentRequirements(e,r){const n=this.registeredClientSchemes.get(e);if(!n)throw new Error(`No client registered for x402 version: ${e}`);const i=r.filter(s=>{let a=d(n,s.network);return a?a.has(s.scheme):!1});if(i.length===0)throw new Error(`No network/scheme registered for x402 version: ${e} which comply with the payment requirements. ${JSON.stringify({x402Version:e,paymentRequirements:r,x402Versions:Array.from(this.registeredClientSchemes.keys()),networks:Array.from(n.keys()),schemes:Array.from(n.values()).map(s=>Array.from(s.keys())).flat()})}`);let o=i;for(const s of this.policies)if(o=s(e,o),o.length===0)throw new Error(`All payment requirements were filtered out by policies for x402 version: ${e}`);return this.paymentRequirementsSelector(e,o)}_registerScheme(e,r,n){this.registeredClientSchemes.has(e)||this.registeredClientSchemes.set(e,new Map);const i=this.registeredClientSchemes.get(e);i.has(r)||i.set(r,new Map);const o=i.get(r);return o.has(n.scheme)||o.set(n.scheme,n),this}};function R(t,e){const r=e instanceof u?e:new u(e);return async(n,i)=>{const o=await t(n,i);if(o.status!==402)return o;let s;try{const h=f=>o.headers.get(f);let m;try{const f=await o.text();f&&(m=JSON.parse(f))}catch{}s=r.getPaymentRequiredResponse(h,m)}catch(h){throw new Error(`Failed to parse payment requirements: ${h instanceof Error?h.message:"Unknown error"}`)}let a;try{a=await e.createPaymentPayload(s)}catch(h){throw new Error(`Failed to create payment payload: ${h instanceof Error?h.message:"Unknown error"}`)}const c=r.encodePaymentSignatureHeader(a);if(!i)throw new Error("Missing fetch request configuration");if(i.__is402Retry)throw new Error("Payment already attempted");const l={...i,headers:{...i.headers||{},...c,"Access-Control-Expose-Headers":"PAYMENT-RESPONSE,X-PAYMENT-RESPONSE"},__is402Retry:!0};return await t(n,l)}}export{w as decodePaymentResponseHeader,R as wrapFetchWithPayment,N as x402Client,u as x402HTTPClient};
