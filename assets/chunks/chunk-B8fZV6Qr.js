import{b0 as L,b1 as O,B as q,b2 as Q,N as x,b3 as I,b4 as B,b5 as U,b6 as W,b7 as j,b8 as K,b9 as k,ba as D,bb as H,bc as Y,Y as J,bd as V,be as X,a1 as m,bf as Z,m as tt,bg as nt,Q as at,R as $,T as et,U as ot,a0 as rt}from"./chunk-CNICcFgQ.js";import{r as ct,b as st,p as it,d as ut,s as dt,c as ht,w as lt,e as wt}from"./chunk-CQlelhe4.js";function ft({chain:t,currentChainId:n}){if(!t)throw new L;if(n!==t.id)throw new O({chain:t,currentChainId:n})}class z extends q{constructor({docsPath:n}={}){super(["Could not find an Account to execute with this Action.","Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."].join(`
`),{docsPath:n,docsSlug:"account",name:"AccountNotFoundError"})}}class A extends q{constructor({docsPath:n,metaMessages:e,type:a}){super(`Account type "${a}" is not supported.`,{docsPath:n,metaMessages:e,name:"AccountTypeNotSupportedError"})}}const E=new W(128);async function pt(t,n){const{account:e=t.account,chain:a=t.chain,accessList:r,authorizationList:c,blobs:s,data:i,gas:u,gasPrice:h,maxFeePerBlobGas:o,maxFeePerGas:f,maxPriorityFeePerGas:l,nonce:w,type:g,value:b,...N}=n;if(typeof e>"u")throw new z({docsPath:"/docs/actions/wallet/sendTransaction"});const d=e?x(e):null;try{Q(n);const p=await(async()=>{if(n.to)return n.to;if(n.to!==null&&c&&c.length>0)return await ct({authorization:c[0]}).catch(()=>{throw new q("`to` is required. Could not infer from `authorizationList`.")})})();if(d?.type==="json-rpc"||d===null){let y;a!==null&&(y=await I(t,st,"getChainId")({}),ft({currentChainId:y,chain:a}));const T=t.chain?.formatters?.transactionRequest?.format,v=(T||B)({...U(N,{format:T}),accessList:r,account:d,authorizationList:c,blobs:s,chainId:y,data:i,gas:u,gasPrice:h,maxFeePerBlobGas:o,maxFeePerGas:f,maxPriorityFeePerGas:l,nonce:w,to:p,type:g,value:b},"sendTransaction"),_=E.get(t.uid),G=_?"wallet_sendTransaction":"eth_sendTransaction";try{return await t.request({method:G,params:[v]},{retryCount:0})}catch(S){if(_===!1)throw S;const C=S;if(C.name==="InvalidInputRpcError"||C.name==="InvalidParamsRpcError"||C.name==="MethodNotFoundRpcError"||C.name==="MethodNotSupportedRpcError")return await t.request({method:"wallet_sendTransaction",params:[v]},{retryCount:0}).then(F=>(E.set(t.uid,!0),F)).catch(F=>{const P=F;throw P.name==="MethodNotFoundRpcError"||P.name==="MethodNotSupportedRpcError"?(E.set(t.uid,!1),C):P});throw C}}if(d?.type==="local"){const y=await I(t,it,"prepareTransactionRequest")({account:d,accessList:r,authorizationList:c,blobs:s,chain:a,data:i,gas:u,gasPrice:h,maxFeePerBlobGas:o,maxFeePerGas:f,maxPriorityFeePerGas:l,nonce:w,nonceManager:d.nonceManager,parameters:[...ut,"sidecars"],type:g,value:b,...N,to:p}),T=a?.serializers?.transaction,M=await d.signTransaction(y,{serializer:T});return await I(t,dt,"sendRawTransaction")({serializedTransaction:M})}throw d?.type==="smart"?new A({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"}):new A({docsPath:"/docs/actions/wallet/sendTransaction",type:d?.type})}catch(p){throw p instanceof A?p:ht(p,{...n,account:d,chain:n.chain||void 0})}}async function R(t,n){return R.internal(t,pt,"sendTransaction",n)}(function(t){async function n(e,a,r,c){const{abi:s,account:i=e.account,address:u,args:h,dataSuffix:o,functionName:f,...l}=c;if(typeof i>"u")throw new z({docsPath:"/docs/contract/writeContract"});const w=i?x(i):null,g=j({abi:s,args:h,functionName:f});try{return await I(e,a,r)({data:`${g}${o?o.replace("0x",""):""}`,to:u,account:w,...l})}catch(b){throw K(b,{abi:s,address:u,args:h,docsPath:"/docs/contract/writeContract",functionName:f,sender:w?.address})}}t.internal=n})(R||(R={}));function Ct(t,n={}){const{key:e="custom",methods:a,name:r="Custom Provider",retryDelay:c}=n;return({retryCount:s})=>k({key:e,methods:a,name:r,request:t.request.bind(t),retryCount:n.retryCount??s,retryDelay:c,type:"custom"})}async function yt(t,n={}){const{assertChainId:e=!0}=n;let a;if(n.connector){const{connector:o}=n;if(t.state.status==="reconnecting"&&!o.getAccounts&&!o.getChainId)throw new D({connector:o});const[f,l]=await Promise.all([o.getAccounts().catch(w=>{if(n.account===null)return[];throw w}),o.getChainId()]);a={accounts:f,chainId:l,connector:o}}else a=t.state.connections.get(t.state.current);if(!a)throw new H;const r=n.chainId??a.chainId,c=await a.connector.getChainId();if(e&&c!==r)throw new Y({connectionChainId:r,connectorChainId:c});const s=a.connector;if(s.getClient)return s.getClient({chainId:r});const i=x(n.account??a.accounts[0]);if(i&&(i.address=J(i.address)),n.account&&!a.accounts.some(o=>o.toLowerCase()===i.address.toLowerCase()))throw new V({address:i.address,connector:s});const u=t.chains.find(o=>o.id===r),h=await a.connector.getProvider({chainId:r});return X({account:i,chain:u,name:"Connector Client",transport:o=>Ct(h)({...o,retryCount:0})})}function Pt(t,n){const{chainId:e,...a}=n,r=t.getClient({chainId:e});return m(r,Z,"readContract")(a)}async function mt(t,n){const{chainId:e,timeout:a=0,...r}=n,c=t.getClient({chainId:e}),i=await m(c,lt,"waitForTransactionReceipt")({...r,timeout:a});if(i.status==="reverted"){const u=m(c,wt,"getTransaction"),{from:h,...o}=await u({hash:i.transactionHash}),l=await m(c,tt,"call")({...o,account:h,data:o.input,gasPrice:o.type!=="eip1559"?o.gasPrice:void 0,maxFeePerGas:o.type==="eip1559"?o.maxFeePerGas:void 0,maxPriorityFeePerGas:o.type==="eip1559"?o.maxPriorityFeePerGas:void 0}),w=l?.data?nt(`0x${l.data.substring(138)}`):"unknown reason";throw new Error(w)}return{...i,chainId:c.chain.id}}async function gt(t,n){const{account:e,chainId:a,connector:r,...c}=n;let s;return typeof e=="object"&&e?.type==="local"?s=t.getClient({chainId:a}):s=await yt(t,{account:e??void 0,assertChainId:!1,chainId:a,connector:r}),await m(s,R,"writeContract")({...c,...e?{account:e}:{},chain:a?{id:a}:null})}function bt(t,n={}){return{async queryFn({queryKey:e}){const{hash:a,...r}=e[1];if(!a)throw new Error("hash is required");return mt(t,{...r,onReplaced:n.onReplaced,hash:a})},queryKey:Tt(n)}}function Tt(t={}){const{onReplaced:n,...e}=t;return["waitForTransactionReceipt",at(e)]}function It(t){return{mutationFn(n){return gt(t,n)},mutationKey:["writeContract"]}}function At(t={}){const{hash:n,query:e={}}=t,a=$(t),r=et({config:a}),c=bt(a,{...t,chainId:t.chainId??r}),s=!!(n&&(e.enabled??!0));return ot({...e,...c,enabled:s})}function Et(t={}){const{mutation:n}=t,e=$(t),a=It(e),{mutate:r,mutateAsync:c,...s}=rt({...n,...a});return{...s,writeContract:r,writeContractAsync:c}}export{z as A,At as a,ft as b,A as c,yt as g,Pt as r,pt as s,Et as u,R as w};
