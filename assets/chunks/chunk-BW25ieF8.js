import{aR as Q,aS as B,aT as K,aU as U,aV as W,B as F,aW as j,X as P,aX as b,aY as k,aZ as D,a_ as X,a$ as H,b0 as V,b1 as Y,b2 as Z,b3 as J,b4 as tt,b5 as nt,b6 as at,b7 as et,_ as y,b8 as ot,q as rt,b9 as ct,ba as v,$ as q,bb as O,bc as z,bd as st,a0 as it}from"./chunk-C0CDn6bf.js";import{r as ut,b as dt,p as ht,d as wt,s as lt,w as ft,c as pt}from"./chunk-DwFTiSeS.js";function Ct({chain:t,currentChainId:n}){if(!t)throw new Q;if(n!==t.id)throw new B({chain:t,currentChainId:n})}function yt(t,{docsPath:n,...e}){const a=(()=>{const o=K(t,e);return o instanceof U?t:o})();return new W(a,{docsPath:n,...e})}class G extends F{constructor({docsPath:n}={}){super(["Could not find an Account to execute with this Action.","Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."].join(`
`),{docsPath:n,docsSlug:"account",name:"AccountNotFoundError"})}}class I extends F{constructor({docsPath:n,metaMessages:e,type:a}){super(`Account type "${a}" is not supported.`,{docsPath:n,metaMessages:e,name:"AccountTypeNotSupportedError"})}}const R=new X(128);async function gt(t,n){const{account:e=t.account,chain:a=t.chain,accessList:o,authorizationList:r,blobs:c,data:s,gas:d,gasPrice:i,maxFeePerBlobGas:u,maxFeePerGas:w,maxPriorityFeePerGas:l,nonce:g,type:A,value:N,...x}=n;if(typeof e>"u")throw new G({docsPath:"/docs/actions/wallet/sendTransaction"});const h=e?P(e):null;try{j(n);const f=await(async()=>{if(n.to)return n.to;if(n.to!==null&&r&&r.length>0)return await ut({authorization:r[0]}).catch(()=>{throw new F("`to` is required. Could not infer from `authorizationList`.")})})();if(h?.type==="json-rpc"||h===null){let C;a!==null&&(C=await b(t,dt,"getChainId")({}),Ct({currentChainId:C,chain:a}));const m=t.chain?.formatters?.transactionRequest?.format,M=(m||k)({...D(x,{format:m}),accessList:o,authorizationList:r,blobs:c,chainId:C,data:s,from:h?.address,gas:d,gasPrice:i,maxFeePerBlobGas:u,maxFeePerGas:w,maxPriorityFeePerGas:l,nonce:g,to:f,type:A,value:N},"sendTransaction"),S=R.get(t.uid),L=S?"wallet_sendTransaction":"eth_sendTransaction";try{return await t.request({method:L,params:[M]},{retryCount:0})}catch($){if(S===!1)throw $;const p=$;if(p.name==="InvalidInputRpcError"||p.name==="InvalidParamsRpcError"||p.name==="MethodNotFoundRpcError"||p.name==="MethodNotSupportedRpcError")return await t.request({method:"wallet_sendTransaction",params:[M]},{retryCount:0}).then(T=>(R.set(t.uid,!0),T)).catch(T=>{const E=T;throw E.name==="MethodNotFoundRpcError"||E.name==="MethodNotSupportedRpcError"?(R.set(t.uid,!1),p):E});throw p}}if(h?.type==="local"){const C=await b(t,ht,"prepareTransactionRequest")({account:h,accessList:o,authorizationList:r,blobs:c,chain:a,data:s,gas:d,gasPrice:i,maxFeePerBlobGas:u,maxFeePerGas:w,maxPriorityFeePerGas:l,nonce:g,nonceManager:h.nonceManager,parameters:[...wt,"sidecars"],type:A,value:N,...x,to:f}),m=a?.serializers?.transaction,_=await h.signTransaction(C,{serializer:m});return await b(t,lt,"sendRawTransaction")({serializedTransaction:_})}throw h?.type==="smart"?new I({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"}):new I({docsPath:"/docs/actions/wallet/sendTransaction",type:h?.type})}catch(f){throw f instanceof I?f:yt(f,{...n,account:h,chain:n.chain||void 0})}}async function mt(t,n){const{abi:e,account:a=t.account,address:o,args:r,dataSuffix:c,functionName:s,...d}=n;if(typeof a>"u")throw new G({docsPath:"/docs/contract/writeContract"});const i=a?P(a):null,u=H({abi:e,args:r,functionName:s});try{return await b(t,gt,"sendTransaction")({data:`${u}${c?c.replace("0x",""):""}`,to:o,account:i,...d})}catch(w){throw V(w,{abi:e,address:o,args:r,docsPath:"/docs/contract/writeContract",functionName:s,sender:i?.address})}}function bt(t,n={}){const{key:e="custom",methods:a,name:o="Custom Provider",retryDelay:r}=n;return({retryCount:c})=>Y({key:e,methods:a,name:o,request:t.request.bind(t),retryCount:n.retryCount??c,retryDelay:r,type:"custom"})}async function Tt(t,n={}){const{assertChainId:e=!0}=n;let a;if(n.connector){const{connector:u}=n;if(t.state.status==="reconnecting"&&!u.getAccounts&&!u.getChainId)throw new Z({connector:u});const[w,l]=await Promise.all([u.getAccounts().catch(g=>{if(n.account===null)return[];throw g}),u.getChainId()]);a={accounts:w,chainId:l,connector:u}}else a=t.state.connections.get(t.state.current);if(!a)throw new J;const o=n.chainId??a.chainId,r=await a.connector.getChainId();if(e&&r!==o)throw new tt({connectionChainId:o,connectorChainId:r});const c=a.connector;if(c.getClient)return c.getClient({chainId:o});const s=P(n.account??a.accounts[0]);if(s&&(s.address=nt(s.address)),n.account&&!a.accounts.some(u=>u.toLowerCase()===s.address.toLowerCase()))throw new at({address:s.address,connector:c});const d=t.chains.find(u=>u.id===o),i=await a.connector.getProvider({chainId:o});return et({account:s,chain:d,name:"Connector Client",transport:u=>bt(i)({...u,retryCount:0})})}function Et(t,n){const{chainId:e,...a}=n,o=t.getClient({chainId:e});return y(o,ot,"readContract")(a)}async function It(t,n){const{chainId:e,timeout:a=0,...o}=n,r=t.getClient({chainId:e}),s=await y(r,ft,"waitForTransactionReceipt")({...o,timeout:a});if(s.status==="reverted"){const i=await y(r,pt,"getTransaction")({hash:s.transactionHash}),w=await y(r,rt,"call")({...i,data:i.input,gasPrice:i.type!=="eip1559"?i.gasPrice:void 0,maxFeePerGas:i.type==="eip1559"?i.maxFeePerGas:void 0,maxPriorityFeePerGas:i.type==="eip1559"?i.maxPriorityFeePerGas:void 0}),l=w?.data?ct(`0x${w.data.substring(138)}`):"unknown reason";throw new Error(l)}return{...s,chainId:r.chain.id}}async function Rt(t,n){const{account:e,chainId:a,connector:o,...r}=n;let c;return typeof e=="object"&&e?.type==="local"?c=t.getClient({chainId:a}):c=await Tt(t,{account:e??void 0,assertChainId:!1,chainId:a,connector:o}),await y(c,mt,"writeContract")({...r,...e?{account:e}:{},chain:a?{id:a}:null})}function Ft(t,n={}){return{async queryFn({queryKey:e}){const a=n.abi;if(!a)throw new Error("abi is required");const{functionName:o,scopeKey:r,...c}=e[1],s=(()=>{const d=e[1];if(d.address)return{address:d.address};if(d.code)return{code:d.code};throw new Error("address or code is required")})();if(!o)throw new Error("functionName is required");return Et(t,{abi:a,functionName:o,args:c.args,...s,...c})},queryKey:Pt(n)}}function Pt(t={}){const{abi:n,...e}=t;return["readContract",v(e)]}function qt(t,n={}){return{async queryFn({queryKey:e}){const{hash:a,...o}=e[1];if(!a)throw new Error("hash is required");return It(t,{...o,onReplaced:n.onReplaced,hash:a})},queryKey:At(n)}}function At(t={}){const{onReplaced:n,...e}=t;return["waitForTransactionReceipt",v(e)]}function Nt(t){return{mutationFn(n){return Rt(t,n)},mutationKey:["writeContract"]}}function Mt(t={}){const{abi:n,address:e,functionName:a,query:o={}}=t,r=t.code,c=q(t),s=O({config:c}),d=Ft(c,{...t,chainId:t.chainId??s}),i=!!((e||r)&&n&&a&&(o.enabled??!0));return z({...o,...d,enabled:i,structuralSharing:o.structuralSharing??st})}function St(t={}){const{hash:n,query:e={}}=t,a=q(t),o=O({config:a}),r=qt(a,{...t,chainId:t.chainId??o}),c=!!(n&&(e.enabled??!0));return z({...e,...r,enabled:c})}function $t(t={}){const{mutation:n}=t,e=q(t),a=Nt(e),{mutate:o,mutateAsync:r,...c}=it({...n,...a});return{...c,writeContract:o,writeContractAsync:r}}export{G as A,$t as a,St as b,Tt as g,Et as r,Mt as u};
