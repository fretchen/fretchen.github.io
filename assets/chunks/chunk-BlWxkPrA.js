import{a5 as B,a6 as K,a7 as L,a8 as W,a9 as j,aa as k,B as U,M as O,ab as E,ac as D,ad as H,ae as X,af as Y,ag as Z,X as g,ah as J,m as V,ai as tt,aj as z,Y as N,ak as G,al as $,am as nt,Z as at}from"./chunk-CRgj_MmV.js";import{r as rt,a as et,p as ot,d as st,s as ct,w as it,b as ut}from"./chunk-Dz2AaeAp.js";import{A as Q,a as b,g as dt}from"./chunk-gk3fjt3L.js";function ht({chain:t,currentChainId:n}){if(!t)throw new B;if(n!==t.id)throw new K({chain:t,currentChainId:n})}function ft(t,{docsPath:n,...a}){const r=(()=>{const e=L(t,a);return e instanceof W?t:e})();return new j(r,{docsPath:n,...a})}const I=new X(128);async function wt(t,n){const{account:a=t.account,chain:r=t.chain,accessList:e,authorizationList:o,blobs:s,data:c,gas:i,gasPrice:h,maxFeePerBlobGas:u,maxFeePerGas:l,maxPriorityFeePerGas:f,nonce:w,type:C,value:T,...x}=n;if(typeof a>"u")throw new Q({docsPath:"/docs/actions/wallet/sendTransaction"});const d=a?O(a):null;try{k(n);const p=await(async()=>{if(n.to)return n.to;if(n.to!==null&&o&&o.length>0)return await rt({authorization:o[0]}).catch(()=>{throw new U("`to` is required. Could not infer from `authorizationList`.")})})();if(d?.type==="json-rpc"||d===null){let m;r!==null&&(m=await E(t,et,"getChainId")({}),ht({currentChainId:m,chain:r}));const R=t.chain?.formatters?.transactionRequest?.format,A=(R||D)({...H(x,{format:R}),accessList:e,authorizationList:o,blobs:s,chainId:m,data:c,from:d?.address,gas:i,gasPrice:h,maxFeePerBlobGas:u,maxFeePerGas:l,maxPriorityFeePerGas:f,nonce:w,to:p,type:C,value:T},"sendTransaction"),_=I.get(t.uid),v=_?"wallet_sendTransaction":"eth_sendTransaction";try{return await t.request({method:v,params:[A]},{retryCount:0})}catch(S){if(_===!1)throw S;const y=S;if(y.name==="InvalidInputRpcError"||y.name==="InvalidParamsRpcError"||y.name==="MethodNotFoundRpcError"||y.name==="MethodNotSupportedRpcError")return await t.request({method:"wallet_sendTransaction",params:[A]},{retryCount:0}).then(q=>(I.set(t.uid,!0),q)).catch(q=>{const P=q;throw P.name==="MethodNotFoundRpcError"||P.name==="MethodNotSupportedRpcError"?(I.set(t.uid,!1),y):P});throw y}}if(d?.type==="local"){const m=await E(t,ot,"prepareTransactionRequest")({account:d,accessList:e,authorizationList:o,blobs:s,chain:r,data:c,gas:i,gasPrice:h,maxFeePerBlobGas:u,maxFeePerGas:l,maxPriorityFeePerGas:f,nonce:w,nonceManager:d.nonceManager,parameters:[...st,"sidecars"],type:C,value:T,...x,to:p}),R=r?.serializers?.transaction,M=await d.signTransaction(m,{serializer:R});return await E(t,ct,"sendRawTransaction")({serializedTransaction:M})}throw d?.type==="smart"?new b({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"}):new b({docsPath:"/docs/actions/wallet/sendTransaction",type:d?.type})}catch(p){throw p instanceof b?p:ft(p,{...n,account:d,chain:n.chain||void 0})}}async function F(t,n){return F.internal(t,wt,"sendTransaction",n)}(function(t){async function n(a,r,e,o){const{abi:s,account:c=a.account,address:i,args:h,dataSuffix:u,functionName:l,...f}=o;if(typeof c>"u")throw new Q({docsPath:"/docs/contract/writeContract"});const w=c?O(c):null,C=Y({abi:s,args:h,functionName:l});try{return await E(a,r,e)({data:`${C}${u?u.replace("0x",""):""}`,to:i,account:w,...f})}catch(T){throw Z(T,{abi:s,address:i,args:h,docsPath:"/docs/contract/writeContract",functionName:l,sender:w?.address})}}t.internal=n})(F||(F={}));function lt(t,n){const{chainId:a,...r}=n,e=t.getClient({chainId:a});return g(e,J,"readContract")(r)}async function pt(t,n){const{chainId:a,timeout:r=0,...e}=n,o=t.getClient({chainId:a}),c=await g(o,it,"waitForTransactionReceipt")({...e,timeout:r});if(c.status==="reverted"){const i=g(o,ut,"getTransaction"),{from:h,...u}=await i({hash:c.transactionHash}),f=await g(o,V,"call")({...u,account:h,data:u.input,gasPrice:u.type!=="eip1559"?u.gasPrice:void 0,maxFeePerGas:u.type==="eip1559"?u.maxFeePerGas:void 0,maxPriorityFeePerGas:u.type==="eip1559"?u.maxPriorityFeePerGas:void 0}),w=f?.data?tt(`0x${f.data.substring(138)}`):"unknown reason";throw new Error(w)}return{...c,chainId:o.chain.id}}async function yt(t,n){const{account:a,chainId:r,connector:e,...o}=n;let s;return typeof a=="object"&&a?.type==="local"?s=t.getClient({chainId:r}):s=await dt(t,{account:a??void 0,assertChainId:!1,chainId:r,connector:e}),await g(s,F,"writeContract")({...o,...a?{account:a}:{},chain:r?{id:r}:null})}function mt(t,n={}){return{async queryFn({queryKey:a}){const r=n.abi;if(!r)throw new Error("abi is required");const{functionName:e,scopeKey:o,...s}=a[1],c=(()=>{const i=a[1];if(i.address)return{address:i.address};if(i.code)return{code:i.code};throw new Error("address or code is required")})();if(!e)throw new Error("functionName is required");return lt(t,{abi:r,functionName:e,args:s.args,...c,...s})},queryKey:gt(n)}}function gt(t={}){const{abi:n,...a}=t;return["readContract",z(a)]}function Ct(t,n={}){return{async queryFn({queryKey:a}){const{hash:r,...e}=a[1];if(!r)throw new Error("hash is required");return pt(t,{...e,onReplaced:n.onReplaced,hash:r})},queryKey:Tt(n)}}function Tt(t={}){const{onReplaced:n,...a}=t;return["waitForTransactionReceipt",z(a)]}function Rt(t){return{mutationFn(n){return yt(t,n)},mutationKey:["writeContract"]}}function Pt(t={}){const{abi:n,address:a,functionName:r,query:e={}}=t,o=t.code,s=N(t),c=G({config:s}),i=mt(s,{...t,chainId:t.chainId??c}),h=!!((a||o)&&n&&r&&(e.enabled??!0));return $({...e,...i,enabled:h,structuralSharing:e.structuralSharing??nt})}function bt(t={}){const{hash:n,query:a={}}=t,r=N(t),e=G({config:r}),o=Ct(r,{...t,chainId:t.chainId??e}),s=!!(n&&(a.enabled??!0));return $({...a,...o,enabled:s})}function It(t={}){const{mutation:n}=t,a=N(t),r=Rt(a),{mutate:e,mutateAsync:o,...s}=at({...n,...r});return{...s,writeContract:e,writeContractAsync:o}}export{It as a,bt as b,lt as r,Pt as u};
