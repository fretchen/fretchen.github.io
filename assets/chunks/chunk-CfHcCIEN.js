import{B as i,E as A,G as p,J as y,K as g,M as E,N as I,O as f,P as m}from"./chunk-Dpsp6vCn.js";class v extends i{constructor({docsPath:t}={}){super(["Could not find an Account to execute with this Action.","Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."].join(`
`),{docsPath:t,docsSlug:"account",name:"AccountNotFoundError"})}}class x extends i{constructor({docsPath:t,metaMessages:s,type:n}){super(`Account type "${n}" is not supported.`,{docsPath:t,metaMessages:s,name:"AccountTypeNotSupportedError"})}}function N(c,t={}){const{key:s="custom",methods:n,name:e="Custom Provider",retryDelay:u}=t;return({retryCount:a})=>A({key:s,methods:n,name:e,request:c.request.bind(c),retryCount:t.retryCount??a,retryDelay:u,type:"custom"})}async function b(c,t={}){const{assertChainId:s=!0}=t;let n;if(t.connector){const{connector:o}=t;if(c.state.status==="reconnecting"&&!o.getAccounts&&!o.getChainId)throw new p({connector:o});const[h,l]=await Promise.all([o.getAccounts().catch(w=>{if(t.account===null)return[];throw w}),o.getChainId()]);n={accounts:h,chainId:l,connector:o}}else n=c.state.connections.get(c.state.current);if(!n)throw new y;const e=t.chainId??n.chainId,u=await n.connector.getChainId();if(s&&u!==e)throw new g({connectionChainId:e,connectorChainId:u});const a=n.connector;if(a.getClient)return a.getClient({chainId:e});const r=E(t.account??n.accounts[0]);if(r&&(r.address=I(r.address)),t.account&&!n.accounts.some(o=>o.toLowerCase()===r.address.toLowerCase()))throw new f({address:r.address,connector:a});const d=c.chains.find(o=>o.id===e),C=await n.connector.getProvider({chainId:e});return m({account:r,chain:d,name:"Connector Client",transport:o=>N(C)({...o,retryCount:0})})}export{v as A,x as a,b as g};
