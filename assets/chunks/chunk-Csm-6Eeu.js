import{b2 as k,b3 as B,B as N,b4 as K,G as S,b5 as E,b6 as Q,b7 as W,b8 as U,b9 as D,ba as H,bb as J,bc as V,bd as X,be as Y,a2 as Z,bf as tt,bg as nt,a3 as m,bh as at,bi as et,bj as ot,bk as rt,x as ct,bl as st,k as it,l as F,r as ut,a4 as z,u as dt,m as ht}from"./chunk-ncxinpTc.js";import{r as wt,c as lt,p as ft,d as pt,s as Ct,e as yt,w as mt,h as gt}from"./chunk-dYGadCQ7.js";function bt({chain:t,currentChainId:n}){if(!t)throw new k;if(n!==t.id)throw new B({chain:t,currentChainId:n})}class L extends N{constructor({docsPath:n}={}){super(["Could not find an Account to execute with this Action.","Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."].join(`
`),{docsPath:n,docsSlug:"account",name:"AccountNotFoundError"})}}class R extends N{constructor({docsPath:n,metaMessages:e,type:a}){super(`Account type "${a}" is not supported.`,{docsPath:n,metaMessages:e,name:"AccountTypeNotSupportedError"})}}const x=new U(128);async function Tt(t,n){const{account:e=t.account,chain:a=t.chain,accessList:o,authorizationList:c,blobs:r,data:i,gas:u,gasPrice:h,maxFeePerBlobGas:s,maxFeePerGas:f,maxPriorityFeePerGas:w,nonce:l,type:g,value:b,...M}=n;if(typeof e>"u")throw new L({docsPath:"/docs/actions/wallet/sendTransaction"});const d=e?S(e):null;try{K(n);const p=await(async()=>{if(n.to)return n.to;if(n.to!==null&&c&&c.length>0)return await wt({authorization:c[0]}).catch(()=>{throw new N("`to` is required. Could not infer from `authorizationList`.")})})();if(d?.type==="json-rpc"||d===null){let y;a!==null&&(y=await E(t,lt,"getChainId")({}),bt({currentChainId:y,chain:a}));const T=t.chain?.formatters?.transactionRequest?.format,_=(T||Q)({...W(M,{format:T}),accessList:o,account:d,authorizationList:c,blobs:r,chainId:y,data:i,gas:u,gasPrice:h,maxFeePerBlobGas:s,maxFeePerGas:f,maxPriorityFeePerGas:w,nonce:l,to:p,type:g,value:b},"sendTransaction"),G=x.get(t.uid),j=G?"wallet_sendTransaction":"eth_sendTransaction";try{return await t.request({method:j,params:[_]},{retryCount:0})}catch(O){if(G===!1)throw O;const C=O;if(C.name==="InvalidInputRpcError"||C.name==="InvalidParamsRpcError"||C.name==="MethodNotFoundRpcError"||C.name==="MethodNotSupportedRpcError")return await t.request({method:"wallet_sendTransaction",params:[_]},{retryCount:0}).then(P=>(x.set(t.uid,!0),P)).catch(P=>{const A=P;throw A.name==="MethodNotFoundRpcError"||A.name==="MethodNotSupportedRpcError"?(x.set(t.uid,!1),C):A});throw C}}if(d?.type==="local"){const y=await E(t,ft,"prepareTransactionRequest")({account:d,accessList:o,authorizationList:c,blobs:r,chain:a,data:i,gas:u,gasPrice:h,maxFeePerBlobGas:s,maxFeePerGas:f,maxPriorityFeePerGas:w,nonce:l,nonceManager:d.nonceManager,parameters:[...pt,"sidecars"],type:g,value:b,...M,to:p}),T=a?.serializers?.transaction,v=await d.signTransaction(y,{serializer:T});return await E(t,Ct,"sendRawTransaction")({serializedTransaction:v})}throw d?.type==="smart"?new R({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"}):new R({docsPath:"/docs/actions/wallet/sendTransaction",type:d?.type})}catch(p){throw p instanceof R?p:yt(p,{...n,account:d,chain:n.chain||void 0})}}async function I(t,n){return I.internal(t,Tt,"sendTransaction",n)}(function(t){async function n(e,a,o,c){const{abi:r,account:i=e.account,address:u,args:h,dataSuffix:s,functionName:f,...w}=c;if(typeof i>"u")throw new L({docsPath:"/docs/contract/writeContract"});const l=i?S(i):null,g=D({abi:r,args:h,functionName:f});try{return await E(e,a,o)({data:`${g}${s?s.replace("0x",""):""}`,to:u,account:l,...w})}catch(b){throw H(b,{abi:r,address:u,args:h,docsPath:"/docs/contract/writeContract",functionName:f,sender:l?.address})}}t.internal=n})(I||(I={}));function Et(t,n={}){const{key:e="custom",methods:a,name:o="Custom Provider",retryDelay:c}=n;return({retryCount:r})=>J({key:e,methods:a,name:o,request:t.request.bind(t),retryCount:n.retryCount??r,retryDelay:c,type:"custom"})}async function It(t,n={}){const{assertChainId:e=!0}=n;let a;if(n.connector){const{connector:s}=n;if(t.state.status==="reconnecting"&&!s.getAccounts&&!s.getChainId)throw new V({connector:s});const[f,w]=await Promise.all([s.getAccounts().catch(l=>{if(n.account===null)return[];throw l}),s.getChainId()]);a={accounts:f,chainId:w,connector:s}}else a=t.state.connections.get(t.state.current);if(!a)throw new X;const o=n.chainId??a.chainId,c=await a.connector.getChainId();if(e&&c!==o)throw new Y({connectionChainId:o,connectorChainId:c});const r=a.connector;if(r.getClient)return r.getClient({chainId:o});const i=S(n.account??a.accounts[0]);if(i&&(i.address=Z(i.address)),n.account&&!a.accounts.some(s=>s.toLowerCase()===i.address.toLowerCase()))throw new tt({address:i.address,connector:r});const u=t.chains.find(s=>s.id===o),h=await a.connector.getProvider({chainId:o});return nt({account:i,chain:u,name:"Connector Client",transport:s=>Et(h)({...s,retryCount:0})})}function Gt(t,n){const{chainId:e,...a}=n,o=t.getClient({chainId:e});return m(o,at,"readContract")(a)}let q=[];function $(t){const n=t.chains;return et(q,n)?q:(q=n,n)}async function Ft(t,n){const{addEthereumChainParameter:e,chainId:a}=n,o=t.state.connections.get(n.connector?.uid??t.state.current);if(o){const r=o.connector;if(!r.switchChain)throw new ot({connector:r});return await r.switchChain({addEthereumChainParameter:e,chainId:a})}const c=t.chains.find(r=>r.id===a);if(!c)throw new rt;return t.setState(r=>({...r,chainId:a})),c}async function Pt(t,n){const{chainId:e,timeout:a=0,...o}=n,c=t.getClient({chainId:e}),i=await m(c,mt,"waitForTransactionReceipt")({...o,timeout:a});if(i.status==="reverted"){const u=m(c,gt,"getTransaction"),{from:h,...s}=await u({hash:i.transactionHash}),w=await m(c,ct,"call")({...s,account:h,data:s.input,gasPrice:s.type!=="eip1559"?s.gasPrice:void 0,maxFeePerGas:s.type==="eip1559"?s.maxFeePerGas:void 0,maxPriorityFeePerGas:s.type==="eip1559"?s.maxPriorityFeePerGas:void 0}),l=w?.data?st(`0x${w.data.substring(138)}`):"unknown reason";throw new Error(l)}return{...i,chainId:c.chain.id}}async function At(t,n){const{account:e,chainId:a,connector:o,...c}=n;let r;return typeof e=="object"&&e?.type==="local"?r=t.getClient({chainId:a}):r=await It(t,{account:e??void 0,assertChainId:!1,chainId:a,connector:o}),await m(r,I,"writeContract")({...c,...e?{account:e}:{},chain:a?{id:a}:null})}function Rt(t,n){const{onChange:e}=n;return t._internal.chains.subscribe((a,o)=>{e(a,o)})}function xt(t){return{mutationFn(n){return Ft(t,n)},mutationKey:["switchChain"]}}function qt(t,n={}){return{async queryFn({queryKey:e}){const{hash:a,...o}=e[1];if(!a)throw new Error("hash is required");return Pt(t,{...o,onReplaced:n.onReplaced,hash:a})},queryKey:Nt(n)}}function Nt(t={}){const{onReplaced:n,...e}=t;return["waitForTransactionReceipt",it(e)]}function St(t){return{mutationFn(n){return At(t,n)},mutationKey:["writeContract"]}}function Mt(t={}){const n=F(t);return ut.useSyncExternalStore(e=>Rt(n,{onChange:e}),()=>$(n),()=>$(n))}function Ot(t={}){const{mutation:n}=t,e=F(t),a=xt(e),{mutate:o,mutateAsync:c,...r}=z({...n,...a});return{...r,chains:Mt({config:e}),switchChain:o,switchChainAsync:c}}function $t(t={}){const{hash:n,query:e={}}=t,a=F(t),o=dt({config:a}),c=qt(a,{...t,chainId:t.chainId??o}),r=!!(n&&(e.enabled??!0));return ht({...e,...c,enabled:r})}function zt(t={}){const{mutation:n}=t,e=F(t),a=St(e),{mutate:o,mutateAsync:c,...r}=z({...n,...a});return{...r,writeContract:o,writeContractAsync:c}}export{L as A,zt as a,$t as b,bt as c,R as d,It as g,Gt as r,Tt as s,Ot as u,I as w};
