import{aV as B,aW as K,B as A,aX as W,y as N,aY as I,aZ as U,a_ as j,a$ as k,b0 as D,b1 as V,b2 as H,b3 as X,b4 as Y,b5 as Z,R as J,b6 as tt,b7 as nt,T as m,b8 as at,m as et,b9 as ot,ba as O,U as x,bb as z,bc as G,bd as rt,V as ct}from"./chunk-D8AR0Meb.js";import{r as st,b as it,p as ut,d as dt,s as ht,c as lt,w as wt,e as ft}from"./chunk-DTLuFKxV.js";function pt({chain:t,currentChainId:n}){if(!t)throw new B;if(n!==t.id)throw new K({chain:t,currentChainId:n})}class L extends A{constructor({docsPath:n}={}){super(["Could not find an Account to execute with this Action.","Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."].join(`
`),{docsPath:n,docsSlug:"account",name:"AccountNotFoundError"})}}class P extends A{constructor({docsPath:n,metaMessages:e,type:a}){super(`Account type "${a}" is not supported.`,{docsPath:n,metaMessages:e,name:"AccountTypeNotSupportedError"})}}const q=new k(128);async function yt(t,n){const{account:e=t.account,chain:a=t.chain,accessList:o,authorizationList:r,blobs:s,data:i,gas:u,gasPrice:d,maxFeePerBlobGas:c,maxFeePerGas:f,maxPriorityFeePerGas:l,nonce:w,type:g,value:b,...M}=n;if(typeof e>"u")throw new L({docsPath:"/docs/actions/wallet/sendTransaction"});const h=e?N(e):null;try{W(n);const p=await(async()=>{if(n.to)return n.to;if(n.to!==null&&r&&r.length>0)return await st({authorization:r[0]}).catch(()=>{throw new A("`to` is required. Could not infer from `authorizationList`.")})})();if(h?.type==="json-rpc"||h===null){let C;a!==null&&(C=await I(t,it,"getChainId")({}),pt({currentChainId:C,chain:a}));const T=t.chain?.formatters?.transactionRequest?.format,S=(T||U)({...j(M,{format:T}),accessList:o,account:h,authorizationList:r,blobs:s,chainId:C,data:i,gas:u,gasPrice:d,maxFeePerBlobGas:c,maxFeePerGas:f,maxPriorityFeePerGas:l,nonce:w,to:p,type:g,value:b},"sendTransaction"),v=q.get(t.uid),Q=v?"wallet_sendTransaction":"eth_sendTransaction";try{return await t.request({method:Q,params:[S]},{retryCount:0})}catch($){if(v===!1)throw $;const y=$;if(y.name==="InvalidInputRpcError"||y.name==="InvalidParamsRpcError"||y.name==="MethodNotFoundRpcError"||y.name==="MethodNotSupportedRpcError")return await t.request({method:"wallet_sendTransaction",params:[S]},{retryCount:0}).then(E=>(q.set(t.uid,!0),E)).catch(E=>{const F=E;throw F.name==="MethodNotFoundRpcError"||F.name==="MethodNotSupportedRpcError"?(q.set(t.uid,!1),y):F});throw y}}if(h?.type==="local"){const C=await I(t,ut,"prepareTransactionRequest")({account:h,accessList:o,authorizationList:r,blobs:s,chain:a,data:i,gas:u,gasPrice:d,maxFeePerBlobGas:c,maxFeePerGas:f,maxPriorityFeePerGas:l,nonce:w,nonceManager:h.nonceManager,parameters:[...dt,"sidecars"],type:g,value:b,...M,to:p}),T=a?.serializers?.transaction,_=await h.signTransaction(C,{serializer:T});return await I(t,ht,"sendRawTransaction")({serializedTransaction:_})}throw h?.type==="smart"?new P({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"}):new P({docsPath:"/docs/actions/wallet/sendTransaction",type:h?.type})}catch(p){throw p instanceof P?p:lt(p,{...n,account:h,chain:n.chain||void 0})}}async function R(t,n){return R.internal(t,yt,"sendTransaction",n)}(function(t){async function n(e,a,o,r){const{abi:s,account:i=e.account,address:u,args:d,dataSuffix:c,functionName:f,...l}=r;if(typeof i>"u")throw new L({docsPath:"/docs/contract/writeContract"});const w=i?N(i):null,g=D({abi:s,args:d,functionName:f});try{return await I(e,a,o)({data:`${g}${c?c.replace("0x",""):""}`,to:u,account:w,...l})}catch(b){throw V(b,{abi:s,address:u,args:d,docsPath:"/docs/contract/writeContract",functionName:f,sender:w?.address})}}t.internal=n})(R||(R={}));function Ct(t,n={}){const{key:e="custom",methods:a,name:o="Custom Provider",retryDelay:r}=n;return({retryCount:s})=>H({key:e,methods:a,name:o,request:t.request.bind(t),retryCount:n.retryCount??s,retryDelay:r,type:"custom"})}async function mt(t,n={}){const{assertChainId:e=!0}=n;let a;if(n.connector){const{connector:c}=n;if(t.state.status==="reconnecting"&&!c.getAccounts&&!c.getChainId)throw new X({connector:c});const[f,l]=await Promise.all([c.getAccounts().catch(w=>{if(n.account===null)return[];throw w}),c.getChainId()]);a={accounts:f,chainId:l,connector:c}}else a=t.state.connections.get(t.state.current);if(!a)throw new Y;const o=n.chainId??a.chainId,r=await a.connector.getChainId();if(e&&r!==o)throw new Z({connectionChainId:o,connectorChainId:r});const s=a.connector;if(s.getClient)return s.getClient({chainId:o});const i=N(n.account??a.accounts[0]);if(i&&(i.address=J(i.address)),n.account&&!a.accounts.some(c=>c.toLowerCase()===i.address.toLowerCase()))throw new tt({address:i.address,connector:s});const u=t.chains.find(c=>c.id===o),d=await a.connector.getProvider({chainId:o});return nt({account:i,chain:u,name:"Connector Client",transport:c=>Ct(d)({...c,retryCount:0})})}function gt(t,n){const{chainId:e,...a}=n,o=t.getClient({chainId:e});return m(o,at,"readContract")(a)}async function bt(t,n){const{chainId:e,timeout:a=0,...o}=n,r=t.getClient({chainId:e}),i=await m(r,wt,"waitForTransactionReceipt")({...o,timeout:a});if(i.status==="reverted"){const u=m(r,ft,"getTransaction"),{from:d,...c}=await u({hash:i.transactionHash}),l=await m(r,et,"call")({...c,account:d,data:c.input,gasPrice:c.type!=="eip1559"?c.gasPrice:void 0,maxFeePerGas:c.type==="eip1559"?c.maxFeePerGas:void 0,maxPriorityFeePerGas:c.type==="eip1559"?c.maxPriorityFeePerGas:void 0}),w=l?.data?ot(`0x${l.data.substring(138)}`):"unknown reason";throw new Error(w)}return{...i,chainId:r.chain.id}}async function Tt(t,n){const{account:e,chainId:a,connector:o,...r}=n;let s;return typeof e=="object"&&e?.type==="local"?s=t.getClient({chainId:a}):s=await mt(t,{account:e??void 0,assertChainId:!1,chainId:a,connector:o}),await m(s,R,"writeContract")({...r,...e?{account:e}:{},chain:a?{id:a}:null})}function It(t,n={}){return{async queryFn({queryKey:e}){const a=n.abi;if(!a)throw new Error("abi is required");const{functionName:o,scopeKey:r,...s}=e[1],i=(()=>{const u=e[1];if(u.address)return{address:u.address};if(u.code)return{code:u.code};throw new Error("address or code is required")})();if(!o)throw new Error("functionName is required");return gt(t,{abi:a,functionName:o,args:s.args,...i,...s})},queryKey:Rt(n)}}function Rt(t={}){const{abi:n,...e}=t;return["readContract",O(e)]}function Et(t,n={}){return{async queryFn({queryKey:e}){const{hash:a,...o}=e[1];if(!a)throw new Error("hash is required");return bt(t,{...o,onReplaced:n.onReplaced,hash:a})},queryKey:Ft(n)}}function Ft(t={}){const{onReplaced:n,...e}=t;return["waitForTransactionReceipt",O(e)]}function Pt(t){return{mutationFn(n){return Tt(t,n)},mutationKey:["writeContract"]}}function Nt(t={}){const{abi:n,address:e,functionName:a,query:o={}}=t,r=t.code,s=x(t),i=z({config:s}),u=It(s,{...t,chainId:t.chainId??i}),d=!!((e||r)&&n&&a&&(o.enabled??!0));return G({...o,...u,enabled:d,structuralSharing:o.structuralSharing??rt})}function xt(t={}){const{hash:n,query:e={}}=t,a=x(t),o=z({config:a}),r=Et(a,{...t,chainId:t.chainId??o}),s=!!(n&&(e.enabled??!0));return G({...e,...r,enabled:s})}function Mt(t={}){const{mutation:n}=t,e=x(t),a=Pt(e),{mutate:o,mutateAsync:r,...s}=ct({...n,...a});return{...s,writeContract:o,writeContractAsync:r}}export{L as A,Mt as a,xt as b,pt as c,P as d,mt as g,gt as r,yt as s,Nt as u,R as w};
