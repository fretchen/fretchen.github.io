import{j as e,c as t}from"./chunk-RwPR_Zb9.js";import{M as i}from"./chunk-CKHCAPN5.js";import"./chunk-ETYCELfk.js";/* empty css              *//* empty css              *//* empty css              */const s=`sequenceDiagram
    Actor Alice as Alice
    participant Contract as Smart Contract
    participant AIService as AI Service
    participant BatchCoord as Batch Coordinator
    participant Settlement as Settlement Layer

    Note over Alice,Contract: Phase 1: Setup - Prepaid Deposit
    Alice->>Contract: Deposit ETH for AI usage
    Contract->>Contract: Update user balance

    Note over Alice,Settlement: Phase 2: Usage - Instant AI Interactions
    Alice->>AIService: Request: "Analyze sentiment"
    AIService->>Contract: Validate sufficient balance
    AIService->>AIService: Process with LLM API
    AIService-->>Alice: Instant AI response
    AIService->>BatchCoord: Queue request for batching

    Note over BatchCoord,Settlement: Phase 3: Settlement - Efficient Batch Processing
    BatchCoord->>BatchCoord: Build Merkle tree from queued requests
    BatchCoord->>Contract: Process batch settlement
    Contract->>Contract: Verify proofs and deduct costs
    Contract->>Settlement: Single efficient transaction
    Settlement-->>Alice: Settlement confirmation`,h={title:"My AI Assistant That Takes ETH Instead of Subscriptions",publishing_date:"2025-08-28",tokenID:41};function d(){return e.jsxs("article",{children:[e.jsxs("section",{children:[e.jsx("p",{children:"While working on some DeFi projects, I noticed something odd: I kept paying Copilot with my credit card while having ETH sitting in my wallet. We can swap tokens instantly without KYC, but AI services still require email verification and monthly subscriptions. So I started wondering - what would an AI that accepts crypto payments actually look like?"}),e.jsxs("p",{children:[e.jsx("strong",{children:"The answer is live:"})," ",e.jsx("a",{href:"/assistent",className:t({fontWeight:"bold",color:"indigo.600",_hover:{color:"indigo.700"}}),children:"Try my AI assistant"})," ","- connect your wallet, deposit ETH, and chat with an LLM. No subscriptions, no accounts, no data harvesting. Just pay for exactly what you use."]}),e.jsx("p",{children:"In this post, I'll walk you through the complete technical implementation - from smart contract architecture to serverless functions - showing my approach to the crypto-native AI problem."}),e.jsxs("div",{className:t({bg:"gray.50",border:"1px solid",borderColor:"gray.200",borderRadius:"lg",p:"md",my:"md"}),children:[e.jsx("h3",{className:t({margin:"0 0 {spacing.3} 0"}),children:"Working Proof-of-Concept"}),e.jsx("p",{className:t({margin:"0 0 {spacing.3} 0"}),children:"This is a functional implementation that demonstrates crypto-native AI payments in production. While fully operational, it's in active development with significant opportunities for optimization and community contributions."}),e.jsxs("p",{className:t({margin:"0"}),children:[e.jsx("strong",{children:"Your input shapes this project:"})," Cost optimizations, UX improvements, and feature requests directly influence the development roadmap."]})]})]}),e.jsxs("section",{children:[e.jsx("h2",{children:"Building on Previous Blockchain-AI Experience"}),e.jsxs("p",{children:["I previously built an ",e.jsx("a",{href:"/blog/9",children:"AI image generator with blockchain payments"}),', proving that crypto-native AI services can work. But LLMs present fundamentally different challenges: users expect multiple requests per session, instant responses, and variable costs per interaction. The traditional "one transaction per request" model becomes prohibitively expensive and cumbersome.']}),e.jsx("p",{children:"For my LLM assistant, I needed to solve three key problems: how to batch multiple requests efficiently, how to maintain instant response times, and how to keep transaction costs reasonable. The solution required rethinking the entire payment architecture around prepaid balances and batch settlement."})]}),e.jsxs("section",{children:[e.jsx("h2",{children:"LLM System Architecture"}),e.jsxs("p",{children:["After evaluating different approaches, Merkle tree batching emerged as the optimal solution - providing cryptographic proof of each interaction while enabling efficient batch processing. This approach balances the competing demands of user experience, cost efficiency, and technical simplicity. I explored this technique in detail in my ",e.jsx("a",{href:"/blog/15",children:"previous post on Merkle tree fundamentals"}),". While that post covered the mathematical foundations, here we'll focus on the practical implementation for real-time AI services."]}),e.jsx("p",{children:"The core architectural change is switching from immediate settlement to a prepaid model with batch processing. Users deposit funds upfront, enabling instant LLM responses while deferring blockchain costs until batch settlement. This creates a trustless system where:"}),e.jsxs("ul",{children:[e.jsx("li",{children:"User deposits $50 → Guaranteed $50 available"}),e.jsx("li",{children:"LLM requests consume balance → No payment risk"}),e.jsx("li",{children:"Batch settlement → Efficient blockchain transactions"}),e.jsx("li",{children:"Refunds possible → User controls remaining balance"})]}),e.jsx("p",{children:"This prepaid model fundamentally changes the user experience compared to traditional per-transaction payments. The workflow below demonstrates how Alice interacts with the system, showing each phase where these benefits become tangible:"}),e.jsx(i,{definition:s,title:"Simplified User Journey: Prepaid AI with Batch Settlement",config:{sequence:{diagramMarginX:50,diagramMarginY:10,boxTextMargin:5,noteMargin:10,messageMargin:35,mirrorActors:!1}}}),e.jsx("h3",{children:"System Data Flow"}),e.jsx("p",{children:"The diagram above illustrates the simplified system architecture with three distinct phases: Setup (deposit), Usage (instant AI interactions), and Settlement (efficient batch processing). Each phase optimizes for different goals - user experience, response speed, and cost efficiency."}),e.jsx("h3",{children:"Core Components"}),e.jsx("p",{children:"Our LLM system consists of three main components working together to enable instant responses with efficient blockchain settlement:"}),e.jsx("h4",{children:"Smart Contract - LLMv1.sol"}),e.jsxs("p",{children:[e.jsx("strong",{children:"Purpose:"})," Manages user deposits, tracks balances, and processes Merkle tree batches for settlement. Built as an upgradeable contract using"," ",e.jsx("a",{href:"https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies#uups",target:"_blank",rel:"noopener noreferrer",children:"OpenZeppelin's UUPS pattern"}),"."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Core Functions:"})," Accept ETH deposits, track user balances, verify Merkle proofs for batch settlement, and enable fund withdrawals."]}),e.jsx("h4",{children:"AI Service (sc_llm.js)"}),e.jsxs("p",{children:[e.jsx("strong",{children:"Purpose:"})," Orchestrates the entire LLM request flow - from balance validation to LLM API calls and batch coordination."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Core Functions:"})," Validate user balances, process LLM requests instantly through OpenAI/Anthropic APIs, and coordinate Merkle tree batching when 4 requests accumulate."]}),e.jsx("h4",{children:"Frontend Interface"}),e.jsxs("p",{children:[e.jsx("strong",{children:"Purpose:"})," Provides the user interface for wallet connection, balance management, and chat interaction."]}),e.jsxs("p",{children:[e.jsx("strong",{children:"Core Functions:"})," Wallet integration, ETH deposits, real-time chat with LLM, and request history tracking."]}),e.jsx("h3",{children:"Critical Implementation Details"}),e.jsx("p",{children:"The system's efficiency comes from three key design decisions that enable instant responses while maintaining cost efficiency:"}),e.jsx("h4",{children:"Merkle Tree Batching"}),e.jsxs("p",{children:["Using"," ",e.jsx("a",{href:"https://github.com/OpenZeppelin/merkle-tree",target:"_blank",rel:"noopener noreferrer",children:"OpenZeppelin's StandardMerkleTree"})," ","library, multiple AI requests get bundled into single blockchain transactions. This reduces per-request costs by approximately 60% compared to individual transactions while maintaining cryptographic proof of each interaction."]}),e.jsx("h4",{children:"Prepaid Balance Architecture"}),e.jsx("p",{children:"Users deposit ETH once and consume balance through LLM requests without repeated wallet confirmations. This eliminates transaction friction while maintaining full control - unused funds can be withdrawn anytime."}),e.jsx("h4",{children:"Automatic Settlement"}),e.jsxs("p",{children:["The system triggers batch settlement when 4 requests accumulate, balancing real-time settlement with transaction efficiency. Running on"," ",e.jsx("a",{href:"https://docs.optimism.io/get-started/superchain",target:"_blank",rel:"noopener noreferrer",children:"Optimism"}),", this threshold ensures users see balance updates quickly while keeping transaction costs under 1 cent - making micro-payments for AI services economically viable today."]}),e.jsx("h2",{children:"Help Shape This Project"}),e.jsx("p",{children:"As an early-stage implementation, your feedback directly influences development priorities and helps validate the crypto-native AI approach. This is exactly the kind of input that makes the Web3 innovation so attractive to me."}),e.jsxs("div",{className:t({bg:"gray.50",border:"1px solid",borderColor:"gray.200",borderRadius:"lg",p:"md",my:"md"}),children:[e.jsx("h3",{className:t({margin:"0 0 {spacing.3} 0"}),children:"Critical Feedback Areas"}),e.jsxs("div",{className:t({mb:"3"}),children:[e.jsx("strong",{children:"Economics:"}),e.jsx("span",{className:t({ml:"2"}),children:"What cost structure would make crypto-AI payments compelling vs. traditional subscriptions? How do L2 fees feel in practice?"})]}),e.jsxs("div",{className:t({mb:"3"}),children:[e.jsx("strong",{children:"User Experience:"}),e.jsx("span",{className:t({ml:"2"}),children:"Where does wallet integration feel clunky? What onboarding steps cause confusion? How intuitive is the prepaid balance model?"})]}),e.jsxs("div",{className:t({mb:"3"}),children:[e.jsx("strong",{children:"Technical Features:"}),e.jsx("span",{className:t({ml:"2"}),children:"What AI capabilities would justify blockchain overhead? How could batch settlement be optimized? Should the system support other LLM providers?"})]}),e.jsxs("p",{className:t({margin:"0"}),children:[e.jsx("strong",{children:"Share your thoughts:"})," Comments below or in"," ",e.jsx("a",{href:"https://github.com/fretchen/fretchen.github.io/issues",children:"GitHub issues"})," - help to build a better crypto-native AI infrastructure."]})]}),e.jsx("h2",{children:"What's Next"}),e.jsx("p",{children:"This implementation proves that blockchain-native AI services can deliver both user control and excellent performance. The next steps focus on expanding capabilities and improving accessibility:"}),e.jsxs("ul",{children:[e.jsxs("li",{children:[e.jsx("strong",{children:"Multiple LLM Support:"})," Integration with Anthropic Claude, local models, and specialized AI services"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Enhanced Batching:"})," Dynamic batch sizes and cross-user optimization for even lower costs"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Account Abstraction Integration:"})," The"," ",e.jsx("a",{href:"https://eip7702.io/",target:"_blank",rel:"noopener noreferrer",children:"EIP-7702 upgrade"})," ","enables smart accounts with native batching capabilities, potentially making the current Merkle tree approach unnecessary while improving UX through gasless interactions"]}),e.jsxs("li",{children:[e.jsx("strong",{children:"Easier User Journey:"})," Improved UX to make the system more accessible and intuitive"]})]}),e.jsx("p",{children:"I believe these technologies might enable more user sovereignty over data surveillance. By combining blockchain payments with efficient batching techniques, we can build AI services that respect privacy, provide transparency, and align incentives between users and providers through the settlement layer."})]})]})}export{d as default,h as meta};
