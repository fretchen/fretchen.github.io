import{aK as b,aL as x,aM as F,aN as q,aO as $,aP as M,aQ as E,aR as C,aS as w,a5 as I,aT as A,aU as T,aV as D,aW as m,aX as G,aY as R,aZ as L,H as y,a_ as N,K as P,a$ as H,S as v,b0 as U,b1 as k,a1 as j}from"./chunk-DvPZXuhD.js";/* empty css              */import"./chunk-DQ3hQvvF.js";/* empty css              *//* empty css              */function B(e){const{abi:s,data:a}=e,r=b(a,0,4),t=s.find(o=>o.type==="function"&&r===x(F(o)));if(!t)throw new q(r,{docsPath:"/docs/contract/decodeFunctionData"});return{functionName:t.name,args:"inputs"in t&&t.inputs&&t.inputs.length>0?$(t.inputs,b(a,4)):void 0}}const p="/docs/contract/encodeErrorResult";function O(e){const{abi:s,errorName:a,args:r}=e;let t=s[0];if(a){const u=M({abi:s,args:r,name:a});if(!u)throw new E(a,{docsPath:p});t=u}if(t.type!=="error")throw new E(void 0,{docsPath:p});const o=F(t),n=x(o);let c="0x";if(r&&r.length>0){if(!t.inputs)throw new C(t.name,{docsPath:p});c=w(t.inputs,r)}return I([n,c])}const h="/docs/contract/encodeFunctionResult";function _(e){const{abi:s,functionName:a,result:r}=e;let t=s[0];if(a){const n=M({abi:s,name:a});if(!n)throw new A(a,{docsPath:h});t=n}if(t.type!=="function")throw new A(void 0,{docsPath:h});if(!t.outputs)throw new T(t.name,{docsPath:h});const o=(()=>{if(t.outputs.length===0)return[];if(t.outputs.length===1)return[r];if(Array.isArray(r))return r;throw new D(r)})();return w(t.outputs,o)}const K="x-batch-gateway:true";async function W(e){const{data:s,ccipRequest:a}=e,{args:[r]}=B({abi:m,data:s}),t=[],o=[];return await Promise.all(r.map(async(n,c)=>{try{o[c]=await a(n),t[c]=!1}catch(u){t[c]=!0,o[c]=J(u)}})),_({abi:m,functionName:"query",result:[t,o]})}function J(e){return e.name==="HttpRequestError"&&e.status?O({abi:m,errorName:"HttpError",args:[e.status,e.shortMessage]}):O({abi:[G],errorName:"Error",args:["shortMessage"in e?e.shortMessage:e.message]})}function Q(e,s){if(!R(e,{strict:!1}))throw new L({address:e});if(!R(s,{strict:!1}))throw new L({address:s});return e.toLowerCase()===s.toLowerCase()}class V extends y{constructor({callbackSelector:s,cause:a,data:r,extraData:t,sender:o,urls:n}){var c;super(a.shortMessage||"An error occurred while fetching for an offchain result.",{cause:a,metaMessages:[...a.metaMessages||[],(c=a.metaMessages)!=null&&c.length?"":[],"Offchain Gateway Call:",n&&["  Gateway URL(s):",...n.map(u=>`    ${N(u)}`)],`  Sender: ${o}`,`  Data: ${r}`,`  Callback selector: ${s}`,`  Extra data: ${t}`].flat(),name:"OffchainLookupError"})}}class X extends y{constructor({result:s,url:a}){super("Offchain gateway response is malformed. Response data must be a hex value.",{metaMessages:[`Gateway URL: ${N(a)}`,`Response: ${P(s)}`],name:"OffchainLookupResponseMalformedError"})}}class Y extends y{constructor({sender:s,to:a}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:[`Contract address: ${a}`,`OffchainLookup sender address: ${s}`],name:"OffchainLookupSenderMismatchError"})}}const nt="0x556f1830",Z={name:"OffchainLookup",type:"error",inputs:[{name:"sender",type:"address"},{name:"urls",type:"string[]"},{name:"callData",type:"bytes"},{name:"callbackFunction",type:"bytes4"},{name:"extraData",type:"bytes"}]};async function ot(e,{blockNumber:s,blockTag:a,data:r,to:t}){const{args:o}=H({data:r,abi:[Z]}),[n,c,u,f,d]=o,{ccipRead:i}=e,g=i&&typeof(i==null?void 0:i.request)=="function"?i.request:z;try{if(!Q(t,n))throw new Y({sender:n,to:t});const l=c.includes(K)?await W({data:u,ccipRequest:g}):await g({data:u,sender:n,urls:c}),{data:S}=await v(e,{blockNumber:s,blockTag:a,data:U([f,w([{type:"bytes"},{type:"bytes"}],[l,d])]),to:t});return S}catch(l){throw new V({callbackSelector:f,cause:l,data:r,extraData:d,sender:n,urls:c})}}async function z({data:e,sender:s,urls:a}){var t;let r=new Error("An unknown error occurred.");for(let o=0;o<a.length;o++){const n=a[o],c=n.includes("{data}")?"GET":"POST",u=c==="POST"?{data:e,sender:s}:void 0,f=c==="POST"?{"Content-Type":"application/json"}:{};try{const d=await fetch(n.replace("{sender}",s.toLowerCase()).replace("{data}",e),{body:JSON.stringify(u),headers:f,method:c});let i;if((t=d.headers.get("Content-Type"))!=null&&t.startsWith("application/json")?i=(await d.json()).data:i=await d.text(),!d.ok){r=new k({body:u,details:i!=null&&i.error?P(i.error):d.statusText,headers:d.headers,status:d.status,url:n});continue}if(!j(i)){r=new X({result:i,url:n});continue}return i}catch(d){r=new k({body:u,details:d.message,url:n})}}throw r}export{z as ccipRequest,ot as offchainLookup,Z as offchainLookupAbiItem,nt as offchainLookupSignature};
