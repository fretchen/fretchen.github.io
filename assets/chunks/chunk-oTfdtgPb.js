import{b1 as B,b2 as K,B as x,b3 as W,M as S,b4 as T,b5 as U,b6 as D,b7 as H,b8 as X,b9 as J,ba as V,bb as Y,bc as Z,bd as tt,X as nt,be as at,bf as et,a1 as m,bg as ot,bh as rt,bi as ct,bj as st,m as it,bk as ut,P as dt,Q as E,r as z,a2 as G,R as L,T as ht,a6 as wt}from"./chunk-BR6TKo75.js";import{r as lt,b as ft,p as Ct,d as pt,s as yt,c as mt,w as gt,e as bt,t as It,f as Tt}from"./chunk-VqaEkCzM.js";function At({chain:t,currentChainId:n}){if(!t)throw new B;if(n!==t.id)throw new K({chain:t,currentChainId:n})}class Q extends x{constructor({docsPath:n}={}){super(["Could not find an Account to execute with this Action.","Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."].join(`
`),{docsPath:n,docsSlug:"account",name:"AccountNotFoundError"})}}class R extends x{constructor({docsPath:n,metaMessages:e,type:a}){super(`Account type "${a}" is not supported.`,{docsPath:n,metaMessages:e,name:"AccountTypeNotSupportedError"})}}const N=new H(128);async function Et(t,n){const{account:e=t.account,chain:a=t.chain,accessList:o,authorizationList:c,blobs:r,data:i,gas:u,gasPrice:h,maxFeePerBlobGas:s,maxFeePerGas:f,maxPriorityFeePerGas:w,nonce:l,type:g,value:b,...M}=n;if(typeof e>"u")throw new Q({docsPath:"/docs/actions/wallet/sendTransaction"});const d=e?S(e):null;try{W(n);const C=await(async()=>{if(n.to)return n.to;if(n.to!==null&&c&&c.length>0)return await lt({authorization:c[0]}).catch(()=>{throw new x("`to` is required. Could not infer from `authorizationList`.")})})();if(d?.type==="json-rpc"||d===null){let y;a!==null&&(y=await T(t,ft,"getChainId")({}),At({currentChainId:y,chain:a}));const I=t.chain?.formatters?.transactionRequest?.format,_=(I||U)({...D(M,{format:I}),accessList:o,account:d,authorizationList:c,blobs:r,chainId:y,data:i,gas:u,gasPrice:h,maxFeePerBlobGas:s,maxFeePerGas:f,maxPriorityFeePerGas:w,nonce:l,to:C,type:g,value:b},"sendTransaction"),O=N.get(t.uid),j=O?"wallet_sendTransaction":"eth_sendTransaction";try{return await t.request({method:j,params:[_]},{retryCount:0})}catch(k){if(O===!1)throw k;const p=k;if(p.name==="InvalidInputRpcError"||p.name==="InvalidParamsRpcError"||p.name==="MethodNotFoundRpcError"||p.name==="MethodNotSupportedRpcError")return await t.request({method:"wallet_sendTransaction",params:[_]},{retryCount:0}).then(P=>(N.set(t.uid,!0),P)).catch(P=>{const F=P;throw F.name==="MethodNotFoundRpcError"||F.name==="MethodNotSupportedRpcError"?(N.set(t.uid,!1),p):F});throw p}}if(d?.type==="local"){const y=await T(t,Ct,"prepareTransactionRequest")({account:d,accessList:o,authorizationList:c,blobs:r,chain:a,data:i,gas:u,gasPrice:h,maxFeePerBlobGas:s,maxFeePerGas:f,maxPriorityFeePerGas:w,nonce:l,nonceManager:d.nonceManager,parameters:[...pt,"sidecars"],type:g,value:b,...M,to:C}),I=a?.serializers?.transaction,v=await d.signTransaction(y,{serializer:I});return await T(t,yt,"sendRawTransaction")({serializedTransaction:v})}throw d?.type==="smart"?new R({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"}):new R({docsPath:"/docs/actions/wallet/sendTransaction",type:d?.type})}catch(C){throw C instanceof R?C:mt(C,{...n,account:d,chain:n.chain||void 0})}}async function A(t,n){return A.internal(t,Et,"sendTransaction",n)}(function(t){async function n(e,a,o,c){const{abi:r,account:i=e.account,address:u,args:h,dataSuffix:s,functionName:f,...w}=c;if(typeof i>"u")throw new Q({docsPath:"/docs/contract/writeContract"});const l=i?S(i):null,g=X({abi:r,args:h,functionName:f});try{return await T(e,a,o)({data:`${g}${s?s.replace("0x",""):""}`,to:u,account:l,...w})}catch(b){throw J(b,{abi:r,address:u,args:h,docsPath:"/docs/contract/writeContract",functionName:f,sender:l?.address})}}t.internal=n})(A||(A={}));function Pt(t,n={}){const{key:e="custom",methods:a,name:o="Custom Provider",retryDelay:c}=n;return({retryCount:r})=>V({key:e,methods:a,name:o,request:t.request.bind(t),retryCount:n.retryCount??r,retryDelay:c,type:"custom"})}async function Ft(t,n={}){const{assertChainId:e=!0}=n;let a;if(n.connector){const{connector:s}=n;if(t.state.status==="reconnecting"&&!s.getAccounts&&!s.getChainId)throw new Y({connector:s});const[f,w]=await Promise.all([s.getAccounts().catch(l=>{if(n.account===null)return[];throw l}),s.getChainId()]);a={accounts:f,chainId:w,connector:s}}else a=t.state.connections.get(t.state.current);if(!a)throw new Z;const o=n.chainId??a.chainId,c=await a.connector.getChainId();if(e&&c!==o)throw new tt({connectionChainId:o,connectorChainId:c});const r=a.connector;if(r.getClient)return r.getClient({chainId:o});const i=S(n.account??a.accounts[0]);if(i&&(i.address=nt(i.address)),n.account&&!a.accounts.some(s=>s.toLowerCase()===i.address.toLowerCase()))throw new at({address:i.address,connector:r});const u=t.chains.find(s=>s.id===o),h=await a.connector.getProvider({chainId:o});return et({account:i,chain:u,name:"Connector Client",transport:s=>Pt(h)({...s,retryCount:0})})}function Gt(t,n){const{chainId:e,...a}=n,o=t.getClient({chainId:e});return m(o,ot,"readContract")(a)}let q=[];function $(t){const n=t.chains;return rt(q,n)?q:(q=n,n)}async function Rt(t,n){const{addEthereumChainParameter:e,chainId:a}=n,o=t.state.connections.get(n.connector?.uid??t.state.current);if(o){const r=o.connector;if(!r.switchChain)throw new ct({connector:r});return await r.switchChain({addEthereumChainParameter:e,chainId:a})}const c=t.chains.find(r=>r.id===a);if(!c)throw new st;return t.setState(r=>({...r,chainId:a})),c}async function Nt(t,n){const{chainId:e,timeout:a=0,...o}=n,c=t.getClient({chainId:e}),i=await m(c,gt,"waitForTransactionReceipt")({...o,timeout:a});if(i.status==="reverted"){const u=m(c,bt,"getTransaction"),{from:h,...s}=await u({hash:i.transactionHash}),w=await m(c,it,"call")({...s,account:h,data:s.input,gasPrice:s.type!=="eip1559"?s.gasPrice:void 0,maxFeePerGas:s.type==="eip1559"?s.maxFeePerGas:void 0,maxPriorityFeePerGas:s.type==="eip1559"?s.maxPriorityFeePerGas:void 0}),l=w?.data?ut(`0x${w.data.substring(138)}`):"unknown reason";throw new Error(l)}return{...i,chainId:c.chain.id}}async function qt(t,n){const{account:e,chainId:a,connector:o,...c}=n;let r;return typeof e=="object"&&e?.type==="local"?r=t.getClient({chainId:a}):r=await Ft(t,{account:e??void 0,assertChainId:!1,chainId:a,connector:o}),await m(r,A,"writeContract")({...c,...e?{account:e}:{},chain:a?{id:a}:null})}function xt(t,n){const{onChange:e}=n;return t._internal.chains.subscribe((a,o)=>{e(a,o)})}function St(t){return{mutationFn(n){return Rt(t,n)},mutationKey:["switchChain"]}}function Mt(t,n={}){return{async queryFn({queryKey:e}){const{hash:a,...o}=e[1];if(!a)throw new Error("hash is required");return Nt(t,{...o,onReplaced:n.onReplaced,hash:a})},queryKey:vt(n)}}function vt(t={}){const{onReplaced:n,...e}=t;return["waitForTransactionReceipt",dt(e)]}function _t(t){return{mutationFn(n){return qt(t,n)},mutationKey:["writeContract"]}}function Ot(t={}){const n=E(t);return z.useSyncExternalStore(e=>xt(n,{onChange:e}),()=>$(n),()=>$(n))}function kt(t={}){const{mutation:n}=t,e=E(t),a=St(e),{mutate:o,mutateAsync:c,...r}=G({...n,...a});return{...r,chains:Ot({config:e}),switchChain:o,switchChainAsync:c}}function Lt(t={}){const{hash:n,query:e={}}=t,a=E(t),o=L({config:a}),c=Mt(a,{...t,chainId:t.chainId??o}),r=!!(n&&(e.enabled??!0));return ht({...e,...c,enabled:r})}function Qt(t={}){const{mutation:n}=t,e=E(t),a=_t(e),{mutate:o,mutateAsync:c,...r}=G({...n,...a});return{...r,writeContract:o,writeContractAsync:c}}function jt(t){const n=L(),{isConnected:e}=wt(),{switchChainAsync:a}=kt(),o=t[0],c=It(n),r=t.includes(c),i=r?c:o,u=z.useCallback(async()=>{if(r||!e)return!0;try{return await a({chainId:Tt(o)}),!0}catch{return!1}},[r,e,a,o]);return{network:i,isOnCorrectNetwork:r,switchIfNeeded:u}}export{Q as A,Qt as a,Lt as b,At as c,R as d,kt as e,Ft as g,Gt as r,Et as s,jt as u,A as w};
