import{aR as B,aS as K,aT as U,aU as W,aV as j,B as A,aW as k,X as N,aX as E,aY as D,aZ as X,a_ as H,a$ as V,b0 as Y,b1 as Z,b2 as J,b3 as tt,b4 as nt,b5 as at,b6 as et,b7 as ot,_ as m,b8 as rt,m as ct,b9 as st,ba as O,$ as x,bb as z,bc as G,bd as it,a0 as ut}from"./chunk-BN_FuO81.js";import{r as dt,b as ht,p as lt,d as ft,s as wt,w as pt,c as Ct}from"./chunk-DboKzleX.js";function yt({chain:t,currentChainId:n}){if(!t)throw new B;if(n!==t.id)throw new K({chain:t,currentChainId:n})}function mt(t,{docsPath:n,...e}){const a=(()=>{const o=U(t,e);return o instanceof W?t:o})();return new j(a,{docsPath:n,...e})}class L extends A{constructor({docsPath:n}={}){super(["Could not find an Account to execute with this Action.","Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."].join(`
`),{docsPath:n,docsSlug:"account",name:"AccountNotFoundError"})}}class P extends A{constructor({docsPath:n,metaMessages:e,type:a}){super(`Account type "${a}" is not supported.`,{docsPath:n,metaMessages:e,name:"AccountTypeNotSupportedError"})}}const q=new H(128);async function gt(t,n){const{account:e=t.account,chain:a=t.chain,accessList:o,authorizationList:r,blobs:s,data:i,gas:u,gasPrice:d,maxFeePerBlobGas:c,maxFeePerGas:w,maxPriorityFeePerGas:l,nonce:f,type:g,value:b,..._}=n;if(typeof e>"u")throw new L({docsPath:"/docs/actions/wallet/sendTransaction"});const h=e?N(e):null;try{k(n);const p=await(async()=>{if(n.to)return n.to;if(n.to!==null&&r&&r.length>0)return await dt({authorization:r[0]}).catch(()=>{throw new A("`to` is required. Could not infer from `authorizationList`.")})})();if(h?.type==="json-rpc"||h===null){let y;a!==null&&(y=await E(t,ht,"getChainId")({}),yt({currentChainId:y,chain:a}));const T=t.chain?.formatters?.transactionRequest?.format,S=(T||D)({...X(_,{format:T}),accessList:o,authorizationList:r,blobs:s,chainId:y,data:i,from:h?.address,gas:u,gasPrice:d,maxFeePerBlobGas:c,maxFeePerGas:w,maxPriorityFeePerGas:l,nonce:f,to:p,type:g,value:b},"sendTransaction"),$=q.get(t.uid),Q=$?"wallet_sendTransaction":"eth_sendTransaction";try{return await t.request({method:Q,params:[S]},{retryCount:0})}catch(v){if($===!1)throw v;const C=v;if(C.name==="InvalidInputRpcError"||C.name==="InvalidParamsRpcError"||C.name==="MethodNotFoundRpcError"||C.name==="MethodNotSupportedRpcError")return await t.request({method:"wallet_sendTransaction",params:[S]},{retryCount:0}).then(R=>(q.set(t.uid,!0),R)).catch(R=>{const F=R;throw F.name==="MethodNotFoundRpcError"||F.name==="MethodNotSupportedRpcError"?(q.set(t.uid,!1),C):F});throw C}}if(h?.type==="local"){const y=await E(t,lt,"prepareTransactionRequest")({account:h,accessList:o,authorizationList:r,blobs:s,chain:a,data:i,gas:u,gasPrice:d,maxFeePerBlobGas:c,maxFeePerGas:w,maxPriorityFeePerGas:l,nonce:f,nonceManager:h.nonceManager,parameters:[...ft,"sidecars"],type:g,value:b,..._,to:p}),T=a?.serializers?.transaction,M=await h.signTransaction(y,{serializer:T});return await E(t,wt,"sendRawTransaction")({serializedTransaction:M})}throw h?.type==="smart"?new P({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"}):new P({docsPath:"/docs/actions/wallet/sendTransaction",type:h?.type})}catch(p){throw p instanceof P?p:mt(p,{...n,account:h,chain:n.chain||void 0})}}async function I(t,n){return I.internal(t,gt,"sendTransaction",n)}(function(t){async function n(e,a,o,r){const{abi:s,account:i=e.account,address:u,args:d,dataSuffix:c,functionName:w,...l}=r;if(typeof i>"u")throw new L({docsPath:"/docs/contract/writeContract"});const f=i?N(i):null,g=V({abi:s,args:d,functionName:w});try{return await E(e,a,o)({data:`${g}${c?c.replace("0x",""):""}`,to:u,account:f,...l})}catch(b){throw Y(b,{abi:s,address:u,args:d,docsPath:"/docs/contract/writeContract",functionName:w,sender:f?.address})}}t.internal=n})(I||(I={}));function bt(t,n={}){const{key:e="custom",methods:a,name:o="Custom Provider",retryDelay:r}=n;return({retryCount:s})=>Z({key:e,methods:a,name:o,request:t.request.bind(t),retryCount:n.retryCount??s,retryDelay:r,type:"custom"})}async function Tt(t,n={}){const{assertChainId:e=!0}=n;let a;if(n.connector){const{connector:c}=n;if(t.state.status==="reconnecting"&&!c.getAccounts&&!c.getChainId)throw new J({connector:c});const[w,l]=await Promise.all([c.getAccounts().catch(f=>{if(n.account===null)return[];throw f}),c.getChainId()]);a={accounts:w,chainId:l,connector:c}}else a=t.state.connections.get(t.state.current);if(!a)throw new tt;const o=n.chainId??a.chainId,r=await a.connector.getChainId();if(e&&r!==o)throw new nt({connectionChainId:o,connectorChainId:r});const s=a.connector;if(s.getClient)return s.getClient({chainId:o});const i=N(n.account??a.accounts[0]);if(i&&(i.address=at(i.address)),n.account&&!a.accounts.some(c=>c.toLowerCase()===i.address.toLowerCase()))throw new et({address:i.address,connector:s});const u=t.chains.find(c=>c.id===o),d=await a.connector.getProvider({chainId:o});return ot({account:i,chain:u,name:"Connector Client",transport:c=>bt(d)({...c,retryCount:0})})}function Et(t,n){const{chainId:e,...a}=n,o=t.getClient({chainId:e});return m(o,rt,"readContract")(a)}async function It(t,n){const{chainId:e,timeout:a=0,...o}=n,r=t.getClient({chainId:e}),i=await m(r,pt,"waitForTransactionReceipt")({...o,timeout:a});if(i.status==="reverted"){const u=m(r,Ct,"getTransaction"),{from:d,...c}=await u({hash:i.transactionHash}),l=await m(r,ct,"call")({...c,account:d,data:c.input,gasPrice:c.type!=="eip1559"?c.gasPrice:void 0,maxFeePerGas:c.type==="eip1559"?c.maxFeePerGas:void 0,maxPriorityFeePerGas:c.type==="eip1559"?c.maxPriorityFeePerGas:void 0}),f=l?.data?st(`0x${l.data.substring(138)}`):"unknown reason";throw new Error(f)}return{...i,chainId:r.chain.id}}async function Rt(t,n){const{account:e,chainId:a,connector:o,...r}=n;let s;return typeof e=="object"&&e?.type==="local"?s=t.getClient({chainId:a}):s=await Tt(t,{account:e??void 0,assertChainId:!1,chainId:a,connector:o}),await m(s,I,"writeContract")({...r,...e?{account:e}:{},chain:a?{id:a}:null})}function Ft(t,n={}){return{async queryFn({queryKey:e}){const a=n.abi;if(!a)throw new Error("abi is required");const{functionName:o,scopeKey:r,...s}=e[1],i=(()=>{const u=e[1];if(u.address)return{address:u.address};if(u.code)return{code:u.code};throw new Error("address or code is required")})();if(!o)throw new Error("functionName is required");return Et(t,{abi:a,functionName:o,args:s.args,...i,...s})},queryKey:Pt(n)}}function Pt(t={}){const{abi:n,...e}=t;return["readContract",O(e)]}function qt(t,n={}){return{async queryFn({queryKey:e}){const{hash:a,...o}=e[1];if(!a)throw new Error("hash is required");return It(t,{...o,onReplaced:n.onReplaced,hash:a})},queryKey:At(n)}}function At(t={}){const{onReplaced:n,...e}=t;return["waitForTransactionReceipt",O(e)]}function Nt(t){return{mutationFn(n){return Rt(t,n)},mutationKey:["writeContract"]}}function Mt(t={}){const{abi:n,address:e,functionName:a,query:o={}}=t,r=t.code,s=x(t),i=z({config:s}),u=Ft(s,{...t,chainId:t.chainId??i}),d=!!((e||r)&&n&&a&&(o.enabled??!0));return G({...o,...u,enabled:d,structuralSharing:o.structuralSharing??it})}function St(t={}){const{hash:n,query:e={}}=t,a=x(t),o=z({config:a}),r=qt(a,{...t,chainId:t.chainId??o}),s=!!(n&&(e.enabled??!0));return G({...e,...r,enabled:s})}function $t(t={}){const{mutation:n}=t,e=x(t),a=Nt(e),{mutate:o,mutateAsync:r,...s}=ut({...n,...a});return{...s,writeContract:o,writeContractAsync:r}}export{L as A,$t as a,St as b,Tt as g,Et as r,Mt as u};
